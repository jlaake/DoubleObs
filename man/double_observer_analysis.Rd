% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DoubleObs_package.r
\docType{data}
\name{double_observer_analysis}
\alias{double_observer_analysis}
\title{Example Double Observer Data Analysis}
\format{
A data frame with 129 observations of 7 variables:
\describe{\item{ch}{a character vector containing the three character encounter history; first occasion indicaes whther the group was marked or not}
\item{count}{number of animals in the group}
\item{het}{variable used to model heterogeneity (re-capture probability.}
\item{lngs}{ natural log of count}
\item{veg}{random vegetation variable}
\item{type}{"unmarked" or "marked"}
}
}
\description{
An example of double observer data analysis but not using marked individuals so residual heterogeneity
cannot be considered.
Data were generated with the following code using simhet function.
}
\details{
simres=simhet(1,150,25,beta=c(-.5,-.5,-1,2,.5),data=data.frame(veg=runif(175)),
             gen_formula="~-1+loc+veg+cov+lngs",use_gs=TRUE,gs_param=c(1,10),seed=9234397)
example_data=simres[[1]][[1]]$results[[1]]$data$data


The groups sizes were randomly generated from a gamma distribution with scale=10 and shape=1 (gs_param).
The true simulated population size is 175 groups and 1732 animals. A uniform random veg variable, and
unmodelled heterogeneity variable cov (uniform -1,1) and natural log of group size are used to
generate p for each location(loc).
}
\examples{
data(example_data)
df=example_data
# Only use second and third capture history positions - first position was for radio(marked)
df$ch=substr(df$ch,2,3)
# Ignore 00 values: these were marked groups that were not detected
df=df[df$ch!="00",]
# all are considered unmarked but need to create empty marked group with call to factor
df$type="unmarked"
df$type=factor(df$type,levels=c("marked","unmarked"))
# Use process.data in RMark but use groups="type" and allgroups=TRUE to create group structure
# even though it is not used. In addition, begin.time=2. These options make double observer
# analysis work with abundance estimation code Nhat functions.
dp=RMark::process.data(df,model="Huggins",groups="type",allgroups=TRUE,begin.time=2)
# Create default design data
ddl=RMark::make.design.data(dp)
# Define create rear 0/1 variable - time==3 (second occasion)
ddl$p$rear=ifelse(ddl$p$time==2,0,1)
ddl$c$rear=1
# show design data
ddl$p
ddl$c
# Create function to fit a sequence of models; must assume independence in this model
# so cannot include c:het:rear or type in models to account for residual heterogeneity
fit.models=function()
{
   p.1=list(formula=~veg+lngs,share=TRUE)
   p.2=list(formula=~lngs+rear,share=TRUE)
   p.3=list(formula=~veg+rear,share=TRUE)
   p.4=list(formula=~veg+lngs+rear,share=TRUE)
   p.5=list(formula=~rear,share=TRUE)
   cml=RMark::create.model.list("Huggins")
   results=RMark::mark.wrapper(cml,data=dp,ddl=ddl)
   return(results)
}
results=fit.models()
results
# Group abundance
Nhat_group_marklist(results,df)
# Group abundance estimate from MARK for best model
results[[1]]$results$derived[[1]][2,]
# MARK doesn't consider group size so there is no equivalent for total abundance
Nhat_marklist(results,df)
}
\keyword{datasets}
